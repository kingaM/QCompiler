import java_cup.runtime.*; 
import ast.*;
import java.util.ArrayList;

parser code {:
public static String section = "Main Body Declaration";
public static int numOfErrors = 0;
public static int numOfMains = 0;

public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    System.exit(1);
}

public void syntax_error(Symbol cur_token) {
    numOfErrors++;
    report_error("Syntax error at line " + (cur_token.left+1) +
   ", column " + (cur_token.right+1) + " at section " + QCup.section , cur_token);
}

:} 
 
terminal        String ID, TYPE, VOID;
terminal		Boolean BOOL;
terminal 		Float FLOAT;
terminal 		Integer INT;
terminal 		String STRING_LITERAL;
terminal		Character CHAR;

terminal 		EQ, NOTEQ, EQCOMP, LESS, LESSOREQ, GREATER, GREATEROREQ, PLUS, MINUS, TIMES, DIVIDE, POWER,
                NOT, OR, AND, SEMI, COLON, LPAREN, RPAREN, LBRACE, RBRACE, LSQPAREN, RSQPAREN, COMMA, LEN, DOT,
                TDEF, FDEF, RETURN, IN, IF, ELSE, DO, WHILE, REPEAT, UNTIL, CONCAT, LTUPLE, RTUPLE;

non terminal    Program program;
non terminal 	ArrayList<Decl> declList;
non terminal 	String typeSpecifier;
non terminal 	Decl functionDecl, functionDeclVoid, functionDeclReturn, variableDecl, typeDecl;
non terminal 	MainDecl mainDecl;
non terminal 	ArrayList<Field> fieldDecl, fieldDeclOptional;
non terminal 	ArrayList<Stmt> funcStmtList, funcBlockStmt,mainStmtList, mainBlockStmt;
non terminal 	Stmt returnStmt, funcStmt, funcStmtNoFollowingSubstmt, mainStmt, mainStmtNoFollowingSubstmt;

non terminal 	Expr expr, fcall, value, sequence, sequenceOptional;


precedence nonassoc EQ, NOTEQ;
precedence left OR, AND;
precedence left EQCOMP,LESS, LESSOREQ, GREATER, GREATEROREQ, IN;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence right POWER;
precedence left NOT;
precedence left LPAREN, RPAREN;
precedence left ELSE, CONCAT, DOT;


program             ::= declList:l mainDecl:m
	                    {: 
	                    //AST
	                    System.out.println(m);
	                    RESULT = new Program(l, m);
	                    
	                    //Errors and info
	                    QCup.section = "Main Declaration"; 
	                    if(QCup.numOfErrors == 0) System.out.println("Parsing successful");
	                    else if(QCup.numOfErrors == 1) System.out.println("Parsing unsuccessful, you had " + QCup.numOfErrors + " error.");
	                    else System.out.println("Parsing unsuccessful, you had " + QCup.numOfErrors + " errors."); 
	                    if(parser.numOfMains > 1) System.err.println("You declared " + parser.numOfMains + " main programs. Only one main is accepted."); 
	                    
	                    :}
	                    | declList error {: System.err.println("No main declaration at the end of file"); :}
	                    ; 

declList             ::= declList:d mainDecl
						{: 
						//AST
						RESULT = d;
						//Error checking
						QCup.section = "Main Body Declaration"; :}
                        | declList:d typeDecl:t
                        {: 
                        //AST
						d.add(t);
						RESULT = d;
						//Error checking
                        QCup.section = "Type Declaration"; :}
                        | declList:d variableDecl:v
                        {: 
                        //AST
						d.add(v);
						RESULT = d;
						//Error checking
                        QCup.section = "Variable Declaration"; :} 
                        | declList:d functionDecl:f
                        {: 
                        //AST
						d.add(f);
						RESULT = d;
						//Error checking
                        QCup.section = "Function Declaration"; :}
                        | 
                        {: RESULT = new ArrayList<Decl>(); :}
                        | declList error RBRACE {: System.err.println("Invalid function definition"); :}
                        ;
                    
typeDecl            ::= TDEF ID:id COLON fieldDecl:f SEMI
						{:
						//AST
						RESULT = new TypeDecl(id, f);
						:}
                        | TDEF error SEMI {: System.err.println("Invalid type declaration"); :}
                        ;
                    
variableDecl        ::= ID:id COLON typeSpecifier:type SEMI
						{:
						RESULT = new VariableDecl(id, type, null);
						:}
                        | ID:id COLON typeSpecifier:type EQ sequence:seq SEMI 
                        {:
						RESULT = new VariableDecl(id, type, seq);
						:}
                        | ID COLON error SEMI {: System.err.println("Invalid variable declaration"); :}
                        ;


functionDecl        ::= functionDeclVoid:f
						{: RESULT = f; :}
                        | functionDeclReturn:f   
                        {: RESULT = f; :}                     
                        | FDEF error RBRACE {: System.err.println("Invalid function definition or missing return statement"); :}
                        ;
                    

functionDeclReturn  ::= FDEF ID:id LPAREN fieldDeclOptional:fieldDecl RPAREN COLON typeSpecifier:type LBRACE funcStmtList:stmts returnStmt:r RBRACE
						{: stmts.add(r);
						RESULT = new FunctionDecl(id, type, fieldDecl, stmts); :}
                        ;
                        

functionDeclVoid    ::= FDEF ID:id LPAREN fieldDeclOptional:fieldDecl RPAREN COLON VOID LBRACE funcStmtList:stmts RBRACE
						{: RESULT = new FunctionDecl(id, "void", fieldDecl, stmts); :}
                        ;


mainDecl     		::= LBRACE mainStmtList RBRACE 
                        {: 
                        //AST
                        RESULT = new MainDecl();
                        
                        //Error
                        if(parser.numOfMains > 1){ parser.numOfErrors ++; }
                               else parser.numOfMains ++; :}
                        | LBRACE error RBRACE {: System.err.println("Invalid main body"); :}
                        ;

 
fieldDeclOptional   ::= fieldDecl
						|
                        ;
                                  

fieldDecl           ::= fieldDecl:f COMMA ID:id COLON typeSpecifier:type
						{: 
						f.add(new Field(id, type));
						RESULT = f;
						:} 
                        | ID:id COLON typeSpecifier:type
                        {:
                        ArrayList<Field> a = new ArrayList<Field>();
                        a.add(new Field(id, type));
                        RESULT = a;
                        :}
                        ;
                    
sequence            ::= sequence COMMA expr
                        | expr
                        ;
        
typeSpecifier      	::= TYPE:t
						{: RESULT = t; :}
                        | ID:id
                        {: RESULT = id; :}
                        ;           

mainStmtList        ::= mainStmtList variableDecl
						| mainStmtList mainStmt
                        |
                        ;
                        
                        
funcStmtList		::= funcStmtList variableDecl
                     	| funcStmtList funcStmt
                    	|
                     	;

sequenceOptional  	::= sequence
                        |
                        ;
                        
                        
fcall               ::= ID:id LPAREN sequenceOptional:seq RPAREN
						{: RESULT = new FcallExpr(id, seq); :}
                        ;

                
mainStmt           	::= mainStmtNoFollowingSubstmt
                        | IF LPAREN expr RPAREN mainBlockStmt
                        | IF error RBRACE {: System.err.println("Invalid if statement"); :}
                        | IF LPAREN expr RPAREN mainBlockStmt ELSE mainBlockStmt
                        | WHILE LPAREN expr RPAREN DO mainBlockStmt  
                        | WHILE error RBRACE {: System.err.println("Invalid while statement"); :} 
                        ;
                        
                  
funcStmt          	::= funcStmtNoFollowingSubstmt
                        | IF LPAREN expr RPAREN funcBlockStmt
                        | IF error RBRACE {: System.err.println("Invalid if statement"); :}
                        | IF LPAREN expr RPAREN funcBlockStmt ELSE funcBlockStmt
                        | WHILE LPAREN expr RPAREN DO funcBlockStmt  
                        | WHILE error RBRACE {: System.err.println("Invalid while statement"); :} 
                        ;
                  
funcBlockStmt      	::= LBRACE funcStmtList RBRACE
                        | error SEMI {: System.err.println("Braces are neccessary"); :} 
                        ;
                        
mainBlockStmt     	::= LBRACE mainStmtList RBRACE
                        | error SEMI {: System.err.println("Braces are neccessary"); :} 
                        ;
                      
funcStmtNoFollowingSubstmt 		::= SEMI
                                    | returnStmt
                                    | REPEAT funcBlockStmt UNTIL LPAREN expr RPAREN
                                    | expr SEMI
                                    | REPEAT error SEMI
                                    ; 
     
mainStmtNoFollowingSubstmt 		::= SEMI
                                    | REPEAT mainBlockStmt UNTIL LPAREN expr RPAREN
                                    | expr SEMI
                                    | REPEAT error SEMI
                                    ;     
                               
returnStmt    		 ::= RETURN SEMI 
                        | RETURN expr SEMI  
                        ;
  
expr				 ::= ID: id
						{: RESULT = new VarExpr(id); :}
                        | value
                        | fcall:f
                        {: RESULT = f; :}
                        | expr:l DOT expr:r
                        {: RESULT = new DotBinaryExpr(l, r); :}
                        | expr:l EQ expr:r 
                        {: RESULT = new EqBinaryExpr(l, r); :}
                        | expr:l CONCAT expr:r
                        {: RESULT = new ConcatBinaryExpr(l, r); :}
                        | LEN LPAREN expr:seq RPAREN 
                        {: RESULT = new FcallExpr("len", seq); :}
                        | expr:l LSQPAREN expr:r RSQPAREN
                        {: RESULT = new SeqExpr(l, r); :}
                        | expr:seq LSQPAREN expr:s COLON expr:f RSQPAREN
                        {: RESULT = new SeqSlicingExpr(seq, s, f); :}
                        | expr:seq LSQPAREN COLON expr:f RSQPAREN
                        {: RESULT = new SeqSlicingExpr(seq, null, f); :}
                        | expr:seq LSQPAREN expr:s COLON RSQPAREN
                        {: RESULT = new SeqSlicingExpr(seq, s, null); :}
                        | expr:l PLUS expr:r
                        {: RESULT = new PlusBinaryExpr(l, r); :}
                        | expr:l MINUS expr:r
                        {: RESULT = new MinusBinaryExpr(l, r); :}
                        | expr:l TIMES expr:r
                        {: RESULT = new TimesBinaryExpr(l, r); :}
                        | expr:l DIVIDE expr:r
                        {: RESULT = new DivideBinaryExpr(l, r); :}
                        | expr:l POWER expr :r
                        {: RESULT = new PowerBinaryExpr(l, r); :}
                        | expr:l EQCOMP expr:r
                        {: RESULT = new EqCompBinaryExpr(l, r); :}
                        | expr:l NOTEQ expr:r
                        {: RESULT = new NotEqCompBinaryExpr(l, r); :}
                        | expr:l LESS expr:r
                        {: RESULT = new LessCompBinaryExpr(l, r); :}
                        | expr:l LESSOREQ expr:r
                        {: RESULT = new LessEqCompBinaryExpr(l, r); :}
                        | expr:l GREATER expr:r
                        {: RESULT = new GreaterCompBinaryExpr(l, r); :}
                        | expr GREATEROREQ expr 
                        | expr OR expr
                        | expr AND expr
                        | NOT expr
                        | expr IN expr
                        | LPAREN expr RPAREN
                        | LTUPLE sequenceOptional RTUPLE
                        | LSQPAREN sequenceOptional RSQPAREN
                        | INT INT {: parser.numOfErrors++; System.err.println("Cannot have two adjacent numbers with no operator in between.\n"); :} 
                        | ID error SEMI {: System.err.println("Invalid expression"); :} 
                        | value error SEMI {: System.err.println("Invalid expression"); :} 
                        ;

value 				::= BOOL
                        | INT
                        | FLOAT
                        | STRING_LITERAL
                        | CHAR
                        ;
