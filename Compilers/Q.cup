import java_cup.runtime.*; 
import ast.*;
import java.util.ArrayList;

parser code {:
public static String section = "Main Body Declaration";
public static int numOfErrors = 0;
public static int numOfMains = 0;

public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    System.exit(1);
}

public void syntax_error(Symbol cur_token) {
    numOfErrors++;
    report_error("Syntax error at line " + (cur_token.left+1) +
   ", column " + (cur_token.right+1) + " at section " + QCup.section , cur_token);
}

:} 
 
terminal        String ID, TYPE, VOID;
terminal		Boolean BOOL;
terminal 		Float FLOAT;
terminal 		Integer INT;
terminal 		String STRING_LITERAL;
terminal		Character CHAR;

terminal 		EQ, NOTEQ, EQCOMP, LESS, LESSOREQ, GREATER, GREATEROREQ, PLUS, MINUS, TIMES, DIVIDE, POWER,
                NOT, OR, AND, SEMI, COLON, LPAREN, RPAREN, LBRACE, RBRACE, LSQPAREN, RSQPAREN, COMMA, LEN, DOT,
                TDEF, FDEF, RETURN, IN, IF, ELSE, DO, WHILE, REPEAT, UNTIL, CONCAT, LTUPLE, RTUPLE;

non terminal    Program program;
non terminal 	ArrayList<Decl> declList;
non terminal 	String typeSpecifier;
non terminal 	Decl functionDecl, functionDeclVoid, functionDeclReturn, variableDecl, typeDecl;
non terminal 	MainDecl mainDecl;
non terminal 	ArrayList<Field> fieldDecl, fieldDeclOptional;
non terminal 	ArrayList<Stmt> funcStmtList, funcBlockStmt,mainStmtList, mainBlockStmt;
non terminal 	Stmt returnStmt, funcStmt, funcStmtNoFollowingSubstmt, mainStmt, mainStmtNoFollowingSubstmt;

non terminal 	Expr expr, fcall, value, sequence, sequenceOptional;


precedence nonassoc EQ, NOTEQ;
precedence left OR, AND;
precedence left EQCOMP,LESS, LESSOREQ, GREATER, GREATEROREQ, IN;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence right POWER;
precedence left NOT;
precedence left LPAREN, RPAREN;
precedence left ELSE, CONCAT, DOT;


program             ::= declList:l mainDecl:m
	                    {: 
	                    //AST
	                    System.out.println(m);
	                    RESULT = new Program(l, m);
	                    
	                    //Errors and info
	                    QCup.section = "Main Declaration"; 
	                    if(QCup.numOfErrors == 0) System.out.println("Parsing successful");
	                    else if(QCup.numOfErrors == 1) System.out.println("Parsing unsuccessful, you had " + QCup.numOfErrors + " error.");
	                    else System.out.println("Parsing unsuccessful, you had " + QCup.numOfErrors + " errors."); 
	                    if(parser.numOfMains > 1) System.err.println("You declared " + parser.numOfMains + " main programs. Only one main is accepted."); 
	                    
	                    :}
	                    | declList error {: System.err.println("No main declaration at the end of file"); :}
	                    ; 

declList             ::= declList:d mainDecl
						{: 
						//AST
						RESULT = d;
						//Error checking
						QCup.section = "Main Body Declaration"; :}
                        | declList:d typeDecl:t
                        {: 
                        //AST
						d.add(t);
						RESULT = d;
						//Error checking
                        QCup.section = "Type Declaration"; :}
                        | declList:d variableDecl:v
                        {: 
                        //AST
						d.add(v);
						RESULT = d;
						//Error checking
                        QCup.section = "Variable Declaration"; :} 
                        | declList:d functionDecl:f
                        {: 
                        //AST
						d.add(f);
						RESULT = d;
						//Error checking
                        QCup.section = "Function Declaration"; :}
                        | 
                        {: RESULT = new ArrayList<Decl>(); :}
                        | declList error RBRACE {: System.err.println("Invalid function definition"); :}
                        ;
                    
typeDecl            ::= TDEF ID COLON fieldDecl SEMI
                        | TDEF error SEMI {: System.err.println("Invalid type declaration"); :}
                        ;
                    
variableDecl        ::= ID:id COLON typeSpecifier:type SEMI
						{:
						RESULT = new VariableDecl(id, type, null);
						:}
                        | ID COLON typeSpecifier EQ sequence SEMI 
                        | ID COLON error SEMI {: System.err.println("Invalid variable declaration"); :}
                        ;


functionDecl        ::= functionDeclVoid
                        | functionDeclReturn                        
                        | FDEF error RBRACE {: System.err.println("Invalid function definition or missing return statement"); :}
                        ;
                    

functionDeclReturn  ::= FDEF ID LPAREN fieldDeclOptional RPAREN COLON typeSpecifier LBRACE funcStmtList returnStmt RBRACE
                        ;
                        

functionDeclVoid    ::= FDEF ID LPAREN fieldDeclOptional RPAREN COLON VOID LBRACE funcStmtList RBRACE
                        ;


mainDecl     		::= LBRACE mainStmtList RBRACE 
                        {: 
                        //AST
                        RESULT = new MainDecl();
                        
                        //Error
                        if(parser.numOfMains > 1){ parser.numOfErrors ++; }
                               else parser.numOfMains ++; :}
                        | LBRACE error RBRACE {: System.err.println("Invalid main body"); :}
                        ;

 
fieldDeclOptional   ::= fieldDecl
						|
                        ;
                                  

fieldDecl           ::= fieldDecl COMMA ID COLON typeSpecifier 
                        | ID COLON typeSpecifier
                        ;
                    
sequence            ::= sequence COMMA expr
                        | expr
                        ;
        
typeSpecifier      	::= TYPE
                        | ID
                        ;           

mainStmtList        ::= mainStmtList variableDecl
						| mainStmtList mainStmt
                        |
                        ;
                        
                        
funcStmtList		::= funcStmtList variableDecl
                     	| funcStmtList funcStmt
                    	|
                     	;

sequenceOptional  	::= sequence
                        |
                        ;
                        
                        
fcall               ::= ID LPAREN sequenceOptional RPAREN
                        ;

                
mainStmt           	::= mainStmtNoFollowingSubstmt
                        | IF LPAREN expr RPAREN mainBlockStmt
                        | IF error RBRACE {: System.err.println("Invalid if statement"); :}
                        | IF LPAREN expr RPAREN mainBlockStmt ELSE mainBlockStmt
                        | WHILE LPAREN expr RPAREN DO mainBlockStmt  
                        | WHILE error RBRACE {: System.err.println("Invalid while statement"); :} 
                        ;
                        
                  
funcStmt          	::= funcStmtNoFollowingSubstmt
                        | IF LPAREN expr RPAREN funcBlockStmt
                        | IF error RBRACE {: System.err.println("Invalid if statement"); :}
                        | IF LPAREN expr RPAREN funcBlockStmt ELSE funcBlockStmt
                        | WHILE LPAREN expr RPAREN DO funcBlockStmt  
                        | WHILE error RBRACE {: System.err.println("Invalid while statement"); :} 
                        ;
                  
funcBlockStmt      	::= LBRACE funcStmtList RBRACE
                        | error SEMI {: System.err.println("Braces are neccessary"); :} 
                        ;
                        
mainBlockStmt     	::= LBRACE funcStmtList RBRACE
                        | error SEMI {: System.err.println("Braces are neccessary"); :} 
                        ;
                      
funcStmtNoFollowingSubstmt 		::= SEMI
                                    | returnStmt
                                    | REPEAT funcBlockStmt UNTIL LPAREN expr RPAREN
                                    | expr SEMI
                                    | REPEAT error SEMI
                                    ; 
     
mainStmtNoFollowingSubstmt 		::= SEMI
                                    | REPEAT mainBlockStmt UNTIL LPAREN expr RPAREN
                                    | expr SEMI
                                    | REPEAT error SEMI
                                    ;     
                               
returnStmt    		 ::= RETURN SEMI 
                        | RETURN expr SEMI  
                        ;
  
expr				 ::= ID
                        | value
                        | fcall
                        | expr DOT expr 
                        | expr EQ expr 
                        | expr CONCAT expr
                        | LEN LPAREN expr RPAREN 
                        | expr LSQPAREN expr RSQPAREN
                        | expr LSQPAREN expr COLON expr RSQPAREN
                        | expr LSQPAREN COLON expr RSQPAREN
                        | expr LSQPAREN expr COLON RSQPAREN
                        | expr PLUS expr
                        | expr MINUS expr
                        | expr TIMES expr
                        | expr DIVIDE expr
                        | expr POWER expr 
                        | expr EQCOMP expr
                        | expr NOTEQ expr
                        | expr LESS expr
                        | expr LESSOREQ expr
                        | expr GREATER expr
                        | expr GREATEROREQ expr 
                        | expr OR expr
                        | expr AND expr
                        | NOT expr
                        | expr IN expr
                        | LPAREN expr RPAREN
                        | LTUPLE sequenceOptional RTUPLE
                        | LSQPAREN sequenceOptional RSQPAREN
                        | INT INT {: parser.numOfErrors++; System.err.println("Cannot have two adjacent numbers with no operator in between.\n"); :} 
                        | ID error SEMI {: System.err.println("Invalid expression"); :} 
                        | value error SEMI {: System.err.println("Invalid expression"); :} 
                        ;

value 				::= BOOL
                        | INT
                        | FLOAT
                        | STRING_LITERAL
                        | CHAR
                        ;
